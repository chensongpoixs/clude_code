# 05｜计划与任务分解（Planning & Tasking）

目标：把“自然语言需求”转换为可执行、可回滚、可验证的步骤序列，并在执行中动态调整。

## 1. 子模块拆分

### 1.1 Planner（计划生成器）
- **输入**：用户任务 + ContextPack + 权限/策略摘要
- **输出**：Plan（见 `docs/01`）
- **策略**：
  - 优先产生“小步快跑”的步骤（每步可验证）
  - 每个步骤声明预期影响文件范围
  - 明确验证命令（lint/test/build）

### 1.2 Todo Runtime（任务运行时）
- **职责**：维护步骤状态、进度、阻塞原因
- **关键能力**：
  - 将 `Step.status` 持久化（断点续跑）
  - 支持 `skip`/`reorder`（需审计记录）

### 1.3 Replanner（动态重规划）
- **触发**：
  - 工具失败/验证失败
  - 发现新信息（例如 grep 命中新的关键文件）
- **输出**：Plan delta（新增/替换步骤）

## 2. 计划质量门槛（可执行性检查）

在进入 `EXECUTING` 前，对计划做静态校验：
- 每个步骤必须有清晰的 `intent`
- 涉及写/删/执行命令的步骤必须标注 `risk_level`
- `verification` 必须定义（哪怕是 `mode: none`）
- 预计修改文件数超过阈值时（如 > 20）要求用户确认或拆分计划

## 3. 人机协作点（何时需要澄清）

### 3.1 必须澄清的情况
- “实现 X 功能”但缺少：
  - 目标接口/页面/入口
  - 兼容性要求（版本/平台）
  - 验收标准（怎么验证）
- 需要改动安全敏感模块（auth/支付/权限）

### 3.2 可默认假设的情况（但要声明）
- 工程约定：优先遵循仓库现有 lint/format
- 验证策略：优先跑 `test`，其次 `lint`，再 `build`

## 4. 回滚与变更粒度

### 4.1 粒度建议
- 一个步骤对应一次“逻辑上自洽”的变更（例如修一个 bug、加一个函数）
- 每 2~5 个步骤执行一次 `VERIFYING`（可配置）

### 4.2 自动回滚策略（建议）
- 若验证失败且定位到最近 patch：回滚最近 patch 再重试修复路径
- 若失败原因是环境缺失：停止并输出手工操作指南


