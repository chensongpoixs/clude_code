# 04｜上下文构建与提示词体系（Context & Prompting）

目标：在 token 预算有限的情况下，为模型提供“刚好够用且高相关”的上下文，提升一次成功率，降低无效工具调用。

## 1. 子模块拆分

### 1.1 意图解析（Intent Parser）
- **输入**：用户自然语言 + 历史会话摘要
- **输出**：
  - `task_type`：bugfix/feature/refactor/docs/devops/analysis
  - `constraints`：不可改范围、必须遵循规范、目标平台
  - `success_criteria`：验收标准（可运行命令/输出）
  - `risk_flags`：可能涉及删除/大范围改动/网络/密钥
- **实现要点**：
  - 轻量规则 + LLM 辅助抽取（但要可解释）

### 1.2 上下文收集（Context Collector）
收集候选信息源：
- 文件树摘要（根目录、关键目录）
- README/贡献指南/脚本入口
- 近期变更（git diff，可选）
- 检索结果（grep/语义）
- 关键文件片段（按行范围）
- 用户提供的片段/错误日志

### 1.3 上下文压缩（Context Compressor）
- **策略**：
  - 结构化摘要（而不是直接贴大段原文）
  - “可引用”片段保留原文（用于精确修改）
  - 去重：同一文件同一片段只出现一次
- **实现要点**：
  - 估算 token：按字符/词近似，或用 tokenizer
  - 分级预算：系统指令 > 用户约束 > 关键代码 > 参考信息

### 1.4 提示词模板（Prompt Templates）

建议将提示词拆为三层：`system`、`developer`、`user`，并为 agent 增加“工具协议与格式约束”的固定片段，保证可控与可审计。

#### 1.4.1 System（不可变）
- 安全边界、禁止事项
- 工具协议与输出格式（例如必须用补丁、必须先计划后执行）
- 隐私与敏感信息规则

#### 1.4.2 Developer（产品策略）
- 交互风格（先澄清、再计划、再执行）
- 执行策略（失败重试、降级、验证闭环）
- 代码风格与仓库约定（从 repo 读取后注入）

#### 1.4.3 User（当次任务）
- 任务描述、输入/输出、限制条件
- 用户提供的日志/截图/片段

## 2. 上下文包（Context Pack）规范

建议将传给模型的上下文做成结构化块，便于调试与回放审计。

### 2.1 ContextPack
- `workspace_summary`：目录摘要 + 关键入口
- `constraints`：必须遵守的规则列表
- `retrieval_hits`：召回命中列表（带分数/来源）
- `code_snippets`：精确片段（path + 行范围 + 内容）
- `recent_actions`：最近工具调用与结果摘要
- `token_budget`：预算与已使用估算

### 2.2 Snippet 规则
- 必须包含：`path`, `start_line`, `end_line`, `content`
- 片段大小上限：建议 150~300 行（可配置）
- 超过上限：优先拆分为多个函数级片段

## 3. 召回→选择→装配（RAG Pipeline）

### 3.1 召回（Retrieve）
- `grep`：用于精确关键词与错误字符串
- `semantic`：用于“功能描述式”的问题（如“登录校验在哪里”）
- `symbol`：用于“调用链/定义引用”（可选）

### 3.2 重排（Rerank）
- 规则重排优先级（建议）：
  - 与用户提到的文件/路径匹配
  - 与错误堆栈文件匹配
  - 更小更聚焦的 chunk 优先

### 3.3 装配（Assemble）
预算分配建议：
- 20%：规则/约束/工具协议（固定）
- 20%：计划与当前状态（todo、已做什么）
- 50%：关键代码片段（可引用）
- 10%：参考信息（README、配置片段）

## 4. 会话摘要（短期记忆）

### 4.1 短期摘要产物
- 每轮结束生成 `session_summary`：
  - 做了哪些工具调用
  - 改了哪些文件
  - 当前阻塞是什么
  - 下一轮建议从哪里继续

### 4.2 历史裁剪
- 只保留最近 N 轮原文 + 全局摘要
- 将“工具输出的大块日志”改成结构化摘要后再入上下文

## 5. 可测性（重要）

### 5.1 离线回放（Replay）
- 存储每轮：
  - 用户输入
  - ContextPack
  - 模型输出
  - 工具调用序列
  - 最终变更（patch/diff）
- 支持在无模型条件下回放工具序列（用于调试/审计）


