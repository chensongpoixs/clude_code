# 阶段 2：自愈闭环（Self-healing Loop）实现报告

## 1. 实现流程详解

自愈闭环（Verification Loop）的设计目标是构建一个“执行 -> 失败 -> 修复”的自治系统，降低 Agent 引入代码缺陷的概率。

### 1.1 核心链路
1.  **触发阶段**：在 `AgentLoop` 执行修改代码的工具（`apply_patch`, `write_file`）或执行命令（`run_cmd`）后，系统自动静默启动验证。
2.  **探测阶段**：`ProjectDetector` 通过工作区特征文件（如 `pyproject.toml`, `package.json`）自动识别项目类型并匹配最佳测试工具。
3.  **运行阶段**：`Verifier` 启动子进程执行验证命令（如 `pytest`），并设置 60s 超时保护。
4.  **解析阶段**：提取 stderr/stdout 中的关键报错（文件名、行号、错误信息），转换为结构化的 `VerificationResult`。
5.  **反馈阶段**：若验证失败，将报错信息注入到 `ToolResult` 的 payload 中，迫使 LLM 在下一个 Turn 必须面对并修复这些错误。

---

## 2. 代码健壮性分析

### 2.1 容错机制
-   **超时保护**：设置了 60s 强制超时，防止因死循环测试或环境阻塞导致 Agent 挂起。
-   **降级策略**：若未探测到已知项目类型，系统返回 `ok=True` 并标记 `type=unknown`，不阻碍 Agent 继续运行。
-   **解析容错**：采用多模式正则表达式解析 Python 错误，若解析失败，则自动回喂输出的尾部信息（Tail），确保 LLM 至少能看到部分上下文。
-   **资源控制**：限制回喂的错误条数为 10 条，避免 Token 爆炸。

### 2.2 潜在风险
-   **环境依赖**：依赖宿主机已安装对应的测试工具（如 `pytest`）。已通过 `ProjectDetector` 尝试多种调用方式（如 `python -m pytest`）来提高成功率。
-   **非代码修改触发**：目前 `run_cmd` 也会触发验证，这在执行非编译类命令时可能带来额外开销，未来可进一步优化为基于命令语义的触发。

---

## 3. 业界对比分析

| 维度 | 业界标准 (如 Aider/Claude Code) | clude-code 实现 | 优势分析 |
| :--- | :--- | :--- | :--- |
| **触发方式** | 通常需要用户手动配置或显式调用 | **全自动触发** | 减少了模型“忘记运行测试”的风险，形成强制安全门。 |
| **错误回喂** | 往往回喂原始文本块 | **结构化摘要 + 关键定位** | 节省 Token，且更易于模型通过 `apply_patch` 精确修复。 |
| **项目适配** | 依赖用户通过 CLI 参数指定测试命令 | **零配置自动探测** | 开箱即用，对新手和多语言仓库更友好。 |
| **自愈深度** | 主要依赖模型自觉 | **编排层强约束** | 在编排层强制注入 `verification_error`，将修复任务提升至最高优先级。 |

---

## 4. 汇报结论

### 4.1 实施结果
- 成功实现了 `src/clude_code/verification/` 模块。
- 成功将验证闭环集成至 `AgentLoop` 主循环。
- 通过结构化反馈机制，Agent 现在能够实时感知其代码修改带来的回归问题。

### 4.2 下一步规划
1. **Lint 集成**：除了单元测试，增加静态代码检查（如 `flake8`）。
2. **多语言解析器**：完善 Node.js 和 Go 的错误正则解析。
3. **性能优化**：引入增量测试，只运行受修改文件影响的测试用例。

